// Copyright (c) 2019, Lukas Wirz
// All rights reserved.

// This file is part of 'nano-tori' which is released under the BSD-2-clause license.
// See file LICENSE in this project.


#include <cmath>
#include <string>
#include <vector>
#include <tuple>

#include "auxiliary.hh"
#include "geometry2.hh"
#include "geometry3.hh"

using namespace std;

#define TORUS 1
#define TUBE 0


int factorial(const int i){
  if(i==0) return 1;
  return i * factorial(i-1);
}

int double_factorial(const int i){
  if(i==0 || i==1) return 1;
  return i * double_factorial(i-2);
}

// after Ivory/Bessel
// minor/major half axis, approximation order
double ellipse_circumference(const double a, const double b, const int n){
  const double h = ((a-b)*(a-b))/((a+b)*(a+b));
  double C = 1 + 0.25*h;
  for(int i=2; i<=n; i++){
    C += pow( double_factorial(2*i-3) / (double_factorial(2*i) ), 2) * pow(h, i);
  }
  C *= M_PI*(a+b);
  return C;
}


// what we're doing is: we need the integral of the product of two functions f
// and g.  f is a function of the angle between the radius and the tangent
// vector.  g is a function of the length of the radius.  For reasons of
// simplicity, we get the Fourier-Cos series of f and g, and expand each
// coefficient in powers of alpha/r.  That works fairly well.

double approximate_that_bloody_integral(const double r0, const double alpha, const double phi){

// change sign
// f0 = r + alpha^2 + alpha^4
// f4 = -alpha^2 - alpha^4
// f8 = -0.25 alpha^4
// 
// g0 = 1 + 0.25 alpha^2
// g2 = -alpha + 0.25 alpha^4
// g4 = -0.25 alpha^2
// g6 = -0.25 alpha^4

  const double dr = alpha/r0;

  const double f0 = 1 + pow(dr, 2) + pow(dr, 4);
  const double f4 = pow(dr, 2) + pow(dr, 4);
  const double f8 = 0.25 * pow(dr, 4);
// cout << "f048: " << f0 << ", " << f4 << ", " << f8 << endl;

  const double g0 = 1 + 0.25*pow(dr, 2);
  const double g2 = -dr + 0.25*pow(dr, 4);
  const double g4 = -0.25*pow(dr, 2);
  const double g6 = -0.25*pow(dr, 4);
// cout << "g0246: " << g0 << ", " << g2 << ", " << g4 << ", " << g6 << endl;

  double integral = 0;
  // f0 g0
  integral += f0 * g0 * phi;
  // f4 g0
  integral += f4 * g0 * (sin(4*phi)/4);
  // f8 g0
  integral += f8 * g0 * (sin(8*phi)/8);

  // f0 g2
  integral += f0 * g2 * (sin(2*phi)/2);
  // f4 g2
  integral += f4 * g2 * (sin(2*phi)/4 + sin(6*phi)/12);
  // f8 g2
  integral += f8 * g2 * (sin(6*phi)/12 + sin(10*phi)/20);

  // f0 g4
  integral += f0 * g4 * (sin(4*phi)/4);
  // f4 g4
  integral += f4 * g4 * (phi/2 + sin(8*phi)/16);
  // f8 g4
  integral += f8 * g4 * (sin(4*phi)/8 + sin(12*phi)/24);

  // f0 g6
  integral += f0 * g6 * (sin(6*phi)/6);
  // f4 g6
  integral += f4 * g6 * (sin(2*phi)/4 + sin(10*phi)/20);
  // f8 g6
  integral += f8 * g6 * (sin(2*phi)/4 + sin(14*phi)/28);

  return integral;
}



int main(int ac, char **av) {

// cerr << ac << endl;
  if (ac != 7) {
    cout << "This program generates grids to be used with the tori generated by torus-full." << endl;
    cout << "usage: " << av[0] << " <m> <n> <p> <q> <bl> <ell>" << endl;
    cout << "  <m>: first component of the chiral vector" << endl;
    cout << "  <n>: second component of the chiral vector" << endl;
    cout << "  <p>: first component of the second side" << endl;
    cout << "  <q>: second component of the second side" << endl;
    cout << "  <target bond length>: 1.43, maybe?" << endl;
    cout << "  <elliptic parameter>: choose '1' for none" << endl;
    abort();
  }
  int m = stol(av[1], 0, 0);
  int n = stol(av[2], 0, 0);
  int p = stol(av[3], 0, 0);
  int q = stol(av[4], 0, 0);
  const double CC_bondlength = stod(av[5], 0);
  const double alpha = stod(av[6], 0);

  cout << "m, n, p, q: " << m << ", " << n << ", " << p << ", " << q << endl;
  cout << "target bond length: " << CC_bondlength << endl;
  cout << "elliptic parameter: " << alpha << endl;

  // the basis vectors in the hexagonal latice
  const coord2d a(sqrt(3), 0);
  const coord2d b(sqrt(3)/2, 1.5);

  // the chiral vector
  const coord2d ch_v(m*a + n*b);
  const double ch_v_length(ch_v.norm());
  const double ch_v_phi(atan2(ch_v[1], ch_v[0]));

  // the other vector
  const coord2d scnd_v(p*a + q*b);
  const double scnd_v_length(scnd_v.norm());
  const double scnd_v_phi(atan2(scnd_v[1], scnd_v[0]));
// cout << "vec, length, angle: " << scnd_v << ", " << scnd_v_length << ", " << scnd_v_phi << endl;

  const double angle_diff = scnd_v_phi - ch_v_phi;
// cout << "angle1, angle2, diff: " << ch_v_phi << ", " <<  scnd_v_phi << ", " << angle_diff << endl;
  if(angle_diff > M_PI){
    cerr << "the chosen p, q imply an angle larger than pi" << endl;
  }
  if(angle_diff < 0){
    cerr << "the chosen p, q imply an angle smaller than 0" << endl;
  }

  // get r and R
  const double r = ch_v_length/(2*M_PI);
  const double rz = r*alpha;
  const double dr = rz - r;
  const double rxy = r - dr;
  // const double h = ((rz-rxy)*(rz-rxy))/((rz+rxy)*(rz+rxy));
  // const double h = (dr*dr)/(r*r);
  // const double C_circle = 2*M_PI*r;
  // const double C_ellipse = M_PI*(rz+rxy)*(1+3*h/(10+sqrt(4-3*h))); // says Ramanujan
  // const double C_ellipse = ellipse_circumference(rz, rxy, 10); // says Bessel
  // cout << "C, C': " << ch_v_length << ", " <<  C_ellipse << ", " << ch_v_length /  C_ellipse << endl;
  const double R = (scnd_v_length * sin(angle_diff))/(2*M_PI); // cos (x-pi/2) = sin (x)
  cout << "R (major radius): " << R << endl;
  cout << "r (minor radius): " << r << endl;
  cout << "rxy (minor radius in horizontal direction): " << rxy << endl;
  cout << "rz (minor radius in vertical direction): " << rz << endl;
  cout << "radius of the hole (R - rxy): " << R-rxy << endl;

  const double integral_over_2pi = approximate_that_bloody_integral(r, dr, 2*M_PI);
  const double integral_over_2pi_normalised = integral_over_2pi / (2*M_PI);
  // cout << integral_over_2pi << endl;
  // cout << integral_over_2pi_normalised << endl;

  const double aa2bohr = 1.889716164632;
  const double bohr2aa = 1/aa2bohr;
  const double spacing = 0.1 * bohr2aa;

  // number of points along the small circumference
  const int n_points_r = int(integral_over_2pi*r / spacing + 0.5);

  // number of points along the large circumference
  const int n_points_R = int(2*M_PI*R / spacing + 0.5);

  const int n_points_radial = int(4.0 / spacing + 0.5); // from -2 to 2

  const int volume_steps = 3; // how many less points for the volume

  cout << "layer grid points: " << n_points_r << "x" << n_points_R << " = " << n_points_r * n_points_R << endl;
  cout << "volume grid points: " << n_points_r/volume_steps << "x" << n_points_R/volume_steps << "x" << n_points_radial/volume_steps << " = " << n_points_r * n_points_R * n_points_radial/pow(volume_steps,3) << endl;


  structure3d layer_m10;
  structure3d layer_m05;
  structure3d layer_0;
  structure3d layer_p05;
  structure3d layer_p10;
  for(int i=0; i<n_points_r; i++){
    for(int j=0; j<n_points_R; j++){
      const double phi  ( i*spacing/r );
      const double theta( j*spacing/R );
  // cout << "phi, theta: " << theta << ", " << phi << endl;
      // modulate phi such that in a torus with ellipsoidal cross section the atoms are less dense at top/bottom and less sparse on the sides
      const double phi_prime = approximate_that_bloody_integral(r, dr, phi) / integral_over_2pi_normalised;
  
      coord3d c3d_m10( (R+(rxy-1)*cos(phi_prime))*cos(theta), (R+(rxy-1)*cos(phi_prime))*sin(theta), (rz-1)*sin(phi_prime) );
      coord3d c3d_m05( (R+(rxy-0.5)*cos(phi_prime))*cos(theta), (R+(rxy-0.5)*cos(phi_prime))*sin(theta), (rz-0.5)*sin(phi_prime) );
      coord3d c3d_0  ( (R+(rxy)*cos(phi_prime))*cos(theta), (R+(rxy)*cos(phi_prime))*sin(theta), (rz)*sin(phi_prime) );
      coord3d c3d_p05( (R+(rxy+0.5)*cos(phi_prime))*cos(theta), (R+(rxy+0.5)*cos(phi_prime))*sin(theta), (rz+0.5)*sin(phi_prime) );
      coord3d c3d_p10( (R+(rxy+1)*cos(phi_prime))*cos(theta), (R+(rxy+1)*cos(phi_prime))*sin(theta), (rz+1)*sin(phi_prime) );

      layer_m10.push_back(c3d_m10);
      layer_m05.push_back(c3d_m05);
      layer_0.push_back(c3d_0);
      layer_p05.push_back(c3d_p05);
      layer_p10.push_back(c3d_p10);

      layer_m10.push_back_atom(string("C"));
      layer_m05.push_back_atom(string("C"));
      layer_0.push_back_atom(string("C"));
      layer_p05.push_back_atom(string("C"));
      layer_p10.push_back_atom(string("C"));
    }
  }

  structure3d layer_vol;
  for(int k=0; k<n_points_radial; k+=volume_steps){
    const double offset( (k-n_points_radial/2)*spacing );
    if(rxy+offset < 0 || rz+offset < 0) continue;
    for(int i=0; i<n_points_r; i+=volume_steps){
      const double phi( i*spacing/r );
      for(int j=0; j<n_points_R; j+=volume_steps){
        const double theta( j*spacing/R );
    // cout << "phi, theta: " << theta << ", " << phi << endl;
        // modulate phi such that in a torus with ellipsoidal cross section the atoms are less dense at top/bottom and less sparse on the sides
        const double phi_prime = approximate_that_bloody_integral(r, dr, phi) / integral_over_2pi_normalised;
    
        coord3d c3d_vol( (R+(rxy+offset)*cos(phi_prime))*cos(theta), (R+(rxy+offset)*cos(phi_prime))*sin(theta), (rz+offset)*sin(phi_prime) );
        layer_vol.push_back(c3d_vol);
        layer_vol.push_back_atom(string("C"));
      }
    }
  }

  layer_m10.scale(CC_bondlength);
  layer_m05.scale(CC_bondlength);
  layer_0.scale(CC_bondlength);
  layer_p05.scale(CC_bondlength);
  layer_p10.scale(CC_bondlength);
  layer_vol.scale(CC_bondlength);
  
  string basename_m10("torus-" + to_string(m) + "-" + to_string(n) + "-" + to_string(p) + "-" + to_string(q) + "-"
                           + to_string_with_precision(CC_bondlength) + "-" + to_string_with_precision(alpha) + "-layer_m10");
  string basename_m05("torus-" + to_string(m) + "-" + to_string(n) + "-" + to_string(p) + "-" + to_string(q) + "-"
                           + to_string_with_precision(CC_bondlength) + "-" + to_string_with_precision(alpha) + "-layer_m05");
  string basename_0("torus-" + to_string(m) + "-" + to_string(n) + "-" + to_string(p) + "-" + to_string(q) + "-"
                           + to_string_with_precision(CC_bondlength) + "-" + to_string_with_precision(alpha) + "-layer_0");
  string basename_p05("torus-" + to_string(m) + "-" + to_string(n) + "-" + to_string(p) + "-" + to_string(q) + "-"
                           + to_string_with_precision(CC_bondlength) + "-" + to_string_with_precision(alpha) + "-layer_p05");
  string basename_p10("torus-" + to_string(m) + "-" + to_string(n) + "-" + to_string(p) + "-" + to_string(q) + "-"
                           + to_string_with_precision(CC_bondlength) + "-" + to_string_with_precision(alpha) + "-layer_p10");
  string basename_vol("torus-" + to_string(m) + "-" + to_string(n) + "-" + to_string(p) + "-" + to_string(q) + "-"
                           + to_string_with_precision(CC_bondlength) + "-" + to_string_with_precision(alpha) + "-vol");
  ofstream xyz_m10((basename_m10 + ".xyz").c_str());
  ofstream xyz_m05((basename_m05 + ".xyz").c_str());
  ofstream xyz_0((basename_0 + ".xyz").c_str());
  ofstream xyz_p05((basename_p05 + ".xyz").c_str());
  ofstream xyz_p10((basename_p10 + ".xyz").c_str());
  ofstream xyz_vol((basename_vol + ".xyz").c_str());

  xyz_m10 << layer_m10.to_xyz();
  xyz_m05 << layer_m05.to_xyz();
  xyz_0 << layer_0.to_xyz();
  xyz_p05 << layer_p05.to_xyz();
  xyz_p10 << layer_p10.to_xyz();
  xyz_vol << layer_vol.to_xyz();

  xyz_m10.close();
  xyz_m05.close();
  xyz_0.close();
  xyz_p05.close();
  xyz_p10.close();
  xyz_vol.close();

  return 0;
}

